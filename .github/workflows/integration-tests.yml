name: Integration Tests

on:
  push:
    branches: [ master, main, develop ]
  pull_request:
    branches: [ master, main, develop ]
  workflow_dispatch:

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  docker-integration:
    name: Docker Integration Tests
    runs-on: ubuntu-latest
    timeout-minutes: 20

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Create .env file for testing
        run: |
          cat > .env << EOF
          POSTGRES_USER=politics
          POSTGRES_PASSWORD=testpassword
          POSTGRES_DB=politics_test_db
          POSTGRES_PORT=5432

          REDIS_PORT=6379

          JWT_SECRET=test-jwt-secret-key-for-integration-tests

          MINIO_ACCESS_KEY=minioadmin
          MINIO_SECRET_KEY=minioadmin
          MINIO_ENDPOINT=minio-test:9000
          MINIO_PUBLIC_ENDPOINT=http://localhost:9000
          MINIO_BUCKET=pulpulitiko-test
          MINIO_USE_SSL=false

          API_PORT=8080
          WEB_PORT=3000

          ENVIRONMENT=test
          EOF

      - name: Start MinIO mock service
        run: |
          # Create network if it doesn't exist
          docker network create pulpulitiko_default || true
          
          # Start MinIO
          docker run -d \
            --name minio-test \
            --network pulpulitiko_default \
            -e MINIO_ROOT_USER=minioadmin \
            -e MINIO_ROOT_PASSWORD=minioadmin \
            -p 9000:9000 \
            -p 9001:9001 \
            minio/minio:latest \
            server /data --console-address ":9001"
          
          echo "Waiting for MinIO to be ready..."
          for i in {1..30}; do
            if curl -f http://localhost:9000/minio/health/live > /dev/null 2>&1; then
              echo "MinIO is ready"
              break
            fi
            if [ $i -eq 30 ]; then
              echo "MinIO failed to start"
              docker logs minio-test
              exit 1
            fi
            sleep 2
          done
          
          # Create test bucket
          docker run --rm --network pulpulitiko_default \
            --entrypoint sh minio/mc:latest \
            -c "mc alias set testminio http://minio-test:9000 minioadmin minioadmin && mc mb testminio/pulpulitiko-test"

      - name: Build Docker images with cache
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./docker/api.Dockerfile
          tags: pulpulitiko-api:ci
          cache-from: type=gha,scope=api
          cache-to: type=gha,mode=max,scope=api
          push: false
          load: true

      - name: Build frontend with cache
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./docker/web.Dockerfile
          tags: pulpulitiko-web:ci
          cache-from: type=gha,scope=web
          cache-to: type=gha,mode=max,scope=web
          push: false
          load: true
          build-args: |
            NUXT_PUBLIC_API_URL=http://localhost:8080/api
            NUXT_PUBLIC_SITE_URL=http://localhost:3000

      - name: Start and verify database services
        run: |
          docker compose -f docker-compose.prod.yml -f docker-compose.ci.yml up -d postgres redis
          
          # Wait for PostgreSQL with retry logic
          echo "Waiting for PostgreSQL..."
          for i in {1..30}; do
            if docker exec pulpulitiko-postgres pg_isready -U politics; then
              echo "PostgreSQL is ready"
              break
            fi
            if [ $i -eq 30 ]; then
              echo "PostgreSQL failed to start"
              docker logs pulpulitiko-postgres
              exit 1
            fi
            sleep 2
          done
          
          # Wait for Redis
          echo "Waiting for Redis..."
          for i in {1..20}; do
            if docker exec pulpulitiko-redis redis-cli ping | grep -q PONG; then
              echo "Redis is ready"
              break
            fi
            if [ $i -eq 20 ]; then
              echo "Redis failed to start"
              docker logs pulpulitiko-redis
              exit 1
            fi
            sleep 1
          done

      - name: Check service health
        run: |
          docker compose -f docker-compose.prod.yml -f docker-compose.ci.yml ps
          docker exec pulpulitiko-postgres pg_isready -U politics || exit 1
          docker exec pulpulitiko-redis redis-cli ping || exit 1

      - name: Start API and run migrations
        run: |
          docker compose -f docker-compose.prod.yml -f docker-compose.ci.yml up -d api
          
          # Wait for API container to be running
          echo "Waiting for API container..."
          for i in {1..30}; do
            if [ "$(docker inspect -f '{{.State.Running}}' pulpulitiko-api 2>/dev/null)" == "true" ]; then
              echo "API container is running"
              break
            fi
            if [ $i -eq 30 ]; then
              echo "API container failed to start"
              docker logs pulpulitiko-api
              exit 1
            fi
            sleep 1
          done
          
          # Run migrations
          echo "Running database migrations..."
          docker exec pulpulitiko-api /usr/local/bin/migrate \
            -path /app/migrations \
            -database "postgres://politics:testpassword@postgres:5432/politics_test_db?sslmode=disable" \
            up

      - name: Seed test data
        run: |
          docker exec -e ADMIN_EMAIL=test@example.com \
                     -e ADMIN_PASSWORD=TestPassword123! \
                     -e ADMIN_NAME="Test Admin" \
                     pulpulitiko-api /app/seed || echo "Seed skipped or failed"

      - name: Wait for API health
        run: |
          echo "Waiting for API to be healthy..."
          for i in {1..60}; do
            if curl -f -s http://localhost:8080/health > /dev/null 2>&1; then
              echo "API is healthy!"
              curl http://localhost:8080/health
              break
            fi
            if [ $i -eq 60 ]; then
              echo "API failed to become healthy"
              docker logs pulpulitiko-api
              exit 1
            fi
            sleep 2
          done

      - name: Start and verify frontend
        run: |
          docker compose -f docker-compose.prod.yml -f docker-compose.ci.yml up -d web
          
          echo "Waiting for frontend..."
          for i in {1..60}; do
            if curl -f -s http://localhost:3000 > /dev/null 2>&1; then
              echo "Frontend is ready!"
              break
            fi
            if [ $i -eq 60 ]; then
              echo "Frontend failed to start"
              docker logs pulpulitiko-web
              exit 1
            fi
            sleep 2
          done

      - name: Run integration tests
        run: |
          # Test API health endpoint
          echo "Testing API health..."
          curl -f http://localhost:8080/health

          # Test API public endpoints
          echo "Testing API public endpoints..."
          curl -f http://localhost:8080/api/articles || echo "Warning: Articles endpoint returned error"
          curl -f http://localhost:8080/api/politicians || echo "Warning: Politicians endpoint returned error"

          # Test frontend
          echo "Testing frontend..."
          timeout 60 sh -c 'until curl -f http://localhost:3000 > /dev/null 2>&1; do sleep 2; done'
          echo "Frontend is accessible!"

      - name: Check logs for errors
        if: always()
        run: |
          echo "=== API Logs ==="
          docker logs pulpulitiko-api --tail 100

          echo "=== Web Logs ==="
          docker logs pulpulitiko-web --tail 100

          echo "=== Postgres Logs ==="
          docker logs pulpulitiko-postgres --tail 50

          echo "=== Redis Logs ==="
          docker logs pulpulitiko-redis --tail 50

      - name: Cleanup
        if: always()
        run: |
          docker compose -f docker-compose.prod.yml -f docker-compose.ci.yml down -v
          docker stop minio-test || true
          docker rm minio-test || true
          docker network rm pulpulitiko_default || true
          rm -f .env

  e2e-tests:
    name: End-to-End Tests
    runs-on: ubuntu-latest
    timeout-minutes: 25
    needs: docker-integration

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Create .env file for testing
        run: |
          cat > .env << EOF
          POSTGRES_USER=politics
          POSTGRES_PASSWORD=testpassword
          POSTGRES_DB=politics_test_db
          POSTGRES_PORT=5432
          REDIS_PORT=6379
          JWT_SECRET=test-jwt-secret-key-for-integration-tests
          MINIO_ACCESS_KEY=minioadmin
          MINIO_SECRET_KEY=minioadmin
          MINIO_ENDPOINT=minio-test:9000
          MINIO_PUBLIC_ENDPOINT=http://localhost:9000
          MINIO_BUCKET=pulpulitiko-test
          MINIO_USE_SSL=false
          API_PORT=8080
          WEB_PORT=3000
          ENVIRONMENT=test
          EOF

      - name: Start MinIO mock service
        run: |
          docker network create pulpulitiko_default || true
          docker run -d \
            --name minio-test \
            --network pulpulitiko_default \
            -e MINIO_ROOT_USER=minioadmin \
            -e MINIO_ROOT_PASSWORD=minioadmin \
            -p 9000:9000 \
            minio/minio:latest \
            server /data
          
          echo "Waiting for MinIO..."
          for i in {1..30}; do
            if curl -f http://localhost:9000/minio/health/live > /dev/null 2>&1; then
              echo "MinIO is ready"
              break
            fi
            sleep 2
          done
          
          docker run --rm --network pulpulitiko_default \
            --entrypoint sh minio/mc:latest \
            -c "mc alias set testminio http://minio-test:9000 minioadmin minioadmin && mc mb testminio/pulpulitiko-test"

      - name: Start test environment
        run: |
          docker compose -f docker-compose.prod.yml -f docker-compose.ci.yml up -d
          
          echo "Waiting for services to be ready..."
          for i in {1..60}; do
            if curl -f http://localhost:8080/health > /dev/null 2>&1 && \
               curl -f http://localhost:3000 > /dev/null 2>&1; then
              echo "All services are ready!"
              break
            fi
            if [ $i -eq 60 ]; then
              echo "Services failed to start"
              docker compose -f docker-compose.prod.yml -f docker-compose.ci.yml logs
              exit 1
            fi
            sleep 3
          done

      - name: Install Playwright
        working-directory: ./web
        run: |
          npm ci
          npx playwright install --with-deps chromium

      - name: Run Playwright e2e tests
        working-directory: ./web
        env:
          BASE_URL: http://localhost:3000
        run: |
          # Run Playwright tests
          npx playwright test --reporter=html

      - name: Upload Playwright report
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: playwright-report
          path: web/playwright-report/
          retention-days: 7

      - name: Cleanup
        if: always()
        run: |
          docker compose -f docker-compose.prod.yml -f docker-compose.ci.yml down -v
          docker stop minio-test || true
          docker rm minio-test || true
          docker network rm pulpulitiko_default || true
          rm -f .env
